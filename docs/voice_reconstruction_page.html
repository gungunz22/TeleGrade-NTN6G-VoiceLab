<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Reconstruction - TELEGRADE-NTN6G-VOICELAB</title>
    <link rel="preload" href="assets/pics/StockSnap_JRVIMXKSYX.jpg" as="image">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        /* voice_reconstruction_page.html specific styles */
        body {
            --background-image-url: url('assets/pics/StockSnap_JRVIMXKSYX.jpg');
            align-items: flex-start;
        }

        .container {
            max-width: 1200px;
            background-color: var(--card-bg);
        }

        h1, h2, h3 {
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        
        .page-subtitle {
            text-align: center;
            font-size: 1.1em;
            color: var(--text-dark);
            margin-bottom: 30px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .audio-samples-section {
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .audio-group {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .audio-item {
            flex: 1;
            margin-bottom: 10px;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .simulator-section, .results-section {
            background-color: rgba(0,0,0,0.2);
            padding: 25px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        h2 {
            font-size: 1.8em;
            margin-top: 0;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .form-group label {
            font-weight: bold;
            color: var(--text-light);
            margin-bottom: 8px;
        }

        .form-group input[type="file"],
        .form-group select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-dark);
            color: var(--text-light);
            box-sizing: border-box;
        }
        
        .slider-container input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 8px var(--primary-color);
        }

        #sinrValue {
            font-weight: bold;
            color: var(--accent-color);
            min-width: 60px;
            text-align: right;
        }

        .run-button {
            background-color: var(--primary-color);
            font-family: 'Orbitron', sans-serif;
        }

        .run-button:hover {
            background-color: var(--primary-dark);
        }
        
        .run-button:disabled {
            background-color: var(--secondary-dark);
            cursor: not-allowed;
            opacity: 0.5;
        }

        #resultsSection {
            display: none;
        }
        
        .result-item .value {
            font-weight: bold;
            color: var(--accent-color);
            font-size: 1.2em;
        }

        audio {
            width: 100%;
            margin-top: 10px;
            filter: invert(1) hue-rotate(180deg);
        }

        .back-button {
            display: inline-block;
            padding: 12px 25px;
            background-color: var(--secondary-dark);
            color: var(--text-light);
            text-decoration: none;
            border-radius: 8px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-weight: 700;
            font-size: 1.1em;
            border: 1px solid var(--border-color);
            font-family: 'Orbitron', sans-serif;
        }
        .back-button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }
        
        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¤ Satellite Voice Reconstruction</h1>
        <p class="page-subtitle">An interactive display for telecom-grade speech quality over a Non-Terrestrial Network (NTN). Upload your audio and adjust parameters to experience the trade-offs in satellite communication.</p>

        <div class="audio-samples-section">
            <h3>Audio Samples</h3>
            <div id="audio-samples-container"></div>
        </div>

        <div class="main-layout">
            <div class="simulator-section">
                <h2>1. Configuration</h2>
                <div class="form-group">
                    <label for="audioUpload">Upload Audio File (.wav, .mp3)</label>
                    <input type="file" id="audioUpload" accept="audio/wav, audio/mpeg">
                </div>
                <div class="form-group">
                    <label for="codecSelect">Select Codec (Bitrate `R_k`)</label>
                    <select id="codecSelect"></select>
                </div>
                <div class="form-group">
                    <label for="sinrSlider">Channel Quality (SINR)</label>
                    <div class="slider-container">
                        <input type="range" id="sinrSlider" min="-5" max="30" value="15" step="1">
                        <span id="sinrValue">15 dB</span>
                    </div>
                </div>
                <button id="runButton" class="run-button" disabled>Upload Audio to Start</button>
            </div>

            <div id="resultsSection" class="results-section">
                <h2>2. Simulation Results</h2>
                <div class="result-item">
                    <p><strong>Original Audio:</strong></p>
                    <audio id="originalAudio" controls></audio>
                </div>
                <hr>
                <div class="result-item">
                    <p>Quantization Distortion: <span id="distortionValue" class="value">N/A</span></p>
                    <p>Packet Error Rate (PER): <span id="perValue" class="value">N/A</span></p>
                    <p>Mean Opinion Score (MoS): <span id="mosValue" class="value">N/A</span></p>
                </div>
                <div class="result-item">
                    <p><strong>Reconstructed Audio (Simulated):</strong></p>
                    <audio id="reconstructedAudio" controls></audio>
                </div>
            </div>
        </div>

        <div class="back-button-wrapper">
            <a href="index.html" class="back-button">Back to Main Page</a>
        </div>
    </div>

    <script>
        // --- Constants and Model Parameters ---
        const DISTORTION_CONST = 0.1; // c in the formula
        const CODECS = {
            'Codec 1 (Low Rate)':  { R: 8000,  alpha: 0.5, beta: 1.5 }, // Low bitrate, sensitive to SINR
            'Codec 2 (Mid Rate)':  { R: 16000, alpha: 0.6, beta: 1.8 }, // Medium bitrate
            'Codec 3 (High Rate)': { R: 32000, alpha: 0.7, beta: 2.0 }  // High bitrate, more robust
        };
        const max_bitrate = Math.max(...Object.values(CODECS).map(c => c.R));

        // --- DOM Elements ---
        const audioUpload = document.getElementById('audioUpload');
        const codecSelect = document.getElementById('codecSelect');
        const sinrSlider = document.getElementById('sinrSlider');
        const sinrValue = document.getElementById('sinrValue');
        const runButton = document.getElementById('runButton');
        const resultsSection = document.getElementById('resultsSection');
        const originalAudio = document.getElementById('originalAudio');
        const reconstructedAudio = document.getElementById('reconstructedAudio');
        const audioSamplesContainer = document.getElementById('audio-samples-container');
        const distortionValue = document.getElementById('distortionValue');
        const perValue = document.getElementById('perValue');
        const mosValue = document.getElementById('mosValue');

        let audioFile = null;
        let originalAudioBuffer = null;
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // --- Core Logic ---

        function populateCodecs() {
            for (const name in CODECS) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = `${name} (${CODECS[name].R / 1000} kbps)`;
                codecSelect.appendChild(option);
            }
        }

        function calculateQuantizationDistortion(R_k, arrival_bits) {
            const rk = R_k; 
            return DISTORTION_CONST * Math.exp(-R_k / max_bitrate) * rk;
        }

        function calculateMos(sinr, codec) {
            const sinrLinear = Math.pow(10, sinr / 10);
            const mos = codec.alpha * Math.log(sinrLinear) + codec.beta;
            return Math.max(1, Math.min(5, mos)); // Clamp MoS between 1 and 5
        }
        
        function calculatePer(sinr) {
            const per = 0.5 * (1 - Math.tanh((sinr - 5) / 10));
            return Math.max(0, Math.min(1, per)); // Clamp PER between 0 and 1
        }

        function applyDistortion(buffer, per) {
            const newBuffer = audioContext.createBuffer(
                buffer.numberOfChannels,
                buffer.length,
                buffer.sampleRate
            );

            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const originalData = buffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                
                const chunkSize = Math.floor(buffer.sampleRate * 0.02); // 20ms chunks
                
                for (let i = 0; i < originalData.length; i += chunkSize) {
                    if (Math.random() < per) {
                        for (let j = i; j < i + chunkSize && j < originalData.length; j++) {
                            newData[j] = 0;
                        }
                    } else {
                        for (let j = i; j < i + chunkSize && j < originalData.length; j++) {
                            newData[j] = originalData[j];
                        }
                    }
                }
            }
            return newBuffer;
        }
        
        function createAudioUrl(buffer) {
            const wav = bufferToWave(buffer);
            const blob = new Blob([wav], { type: 'audio/wav' });
            return URL.createObjectURL(blob);
        }

        // --- Event Listeners ---

        sinrSlider.addEventListener('input', () => {
            sinrValue.textContent = `${sinrSlider.value} dB`;
        });

        audioUpload.addEventListener('change', (event) => {
            audioFile = event.target.files[0];
            if (audioFile) {
                runButton.textContent = 'Processing...';
                runButton.disabled = true;
                const reader = new FileReader();
                reader.onload = (e) => {
                    audioContext.decodeAudioData(e.target.result, (buffer) => {
                        originalAudioBuffer = buffer;
                        originalAudio.src = URL.createObjectURL(audioFile);
                        runButton.disabled = false;
                        runButton.textContent = 'Run Simulation';
                        resultsSection.style.display = 'grid';
                    }, (error) => {
                        alert('Error decoding audio file. Please try a different file.');
                        runButton.textContent = 'Upload Audio to Start';
                    });
                };
                reader.readAsArrayBuffer(audioFile);
            }
        });

        runButton.addEventListener('click', () => {
            if (!originalAudioBuffer) {
                alert('Please upload an audio file first.');
                return;
            }

            const selectedCodecName = codecSelect.value;
            const selectedCodec = CODECS[selectedCodecName];
            const sinr = parseFloat(sinrSlider.value);

            const distortion = calculateQuantizationDistortion(selectedCodec.R, selectedCodec.R);
            const mos = calculateMos(sinr, selectedCodec);
            const per = calculatePer(sinr);

            const reconstructedBuffer = applyDistortion(originalAudioBuffer, per);
            reconstructedAudio.src = createAudioUrl(reconstructedBuffer);

            distortionValue.textContent = distortion.toFixed(2);
            perValue.textContent = `${(per * 100).toFixed(1)}%`;
            mosValue.textContent = `${mos.toFixed(2)} / 5.0`;
        });

        // --- Audio Samples ---
        const audioSamples = [
            { name: 'Sample 1 - Original', path: 'assets/audio/sample1_original.wav' },
            { name: 'Sample 1 - Reconstructed', path: 'assets/audio/sample1_reconstructed.wav' },
            { name: 'Sample 2 - Original', path: 'assets/audio/sample2_original.wav' },
            { name: 'Sample 2 - Reconstructed', path: 'assets/audio/sample2_reconstructed.wav' }
        ];

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        async function displayAudioSamples() {
            for (let i = 0; i < audioSamples.length; i += 2) {
                const group = document.createElement('div');
                group.className = 'audio-group';

                for (let j = i; j < i + 2 && j < audioSamples.length; j++) {
                    const sample = audioSamples[j];
                    const item = document.createElement('div');
                    item.className = 'audio-item';

                    const name = document.createElement('p');
                    name.textContent = sample.name;
                    item.appendChild(name);

                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = sample.path;
                    item.appendChild(audio);

                    const size = document.createElement('p');
                    size.textContent = 'File size: Loading...';
                    item.appendChild(size);

                    group.appendChild(item);

                    fetch(sample.path, { method: 'HEAD' })
                        .then(response => {
                            if (response.ok) {
                                const fileSize = response.headers.get('content-length');
                                if (fileSize) {
                                    size.textContent = `File size: ${formatBytes(fileSize)}`;
                                } else {
                                    size.textContent = 'File size: N/A';
                                }
                            } else {
                                size.textContent = 'File size: Not found';
                            }
                        })
                        .catch(() => {
                            size.textContent = 'File size: Error';
                        });
                }
                audioSamplesContainer.appendChild(group);
            }
        }

        // --- Initialization ---
        populateCodecs();
        displayAudioSamples();
        
        function bufferToWave(abuffer) {
            let numOfChan = abuffer.numberOfChannels,
                length = abuffer.length * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample, offset = 0, pos = 0;
            setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
            setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
            setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164);
            setUint32(length - pos - 4);
            for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
            while (pos < length) {
                for (i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                    view.setInt16(pos, sample, true); pos += 2;
                }
                offset++;
            }
            return buffer;
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        }
    </script>
</body>
</html>
